<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<table>
    <tbody>
    <tr>
        <td> 元字符</td>
        <td> 描述</td>
    </tr>
    <tr>
        <td> \</td>
        <td> 将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\\n”匹配\n。“\n”匹配换行符。序列“\\”匹配“\”而“\(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。</td>
    </tr>
    <tr>
        <td> ^</td>
        <td> 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td>
    </tr>
    <tr>
        <td> $</td>
        <td> 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td>
    </tr>
    <tr>
        <td> *</td>
        <td> 匹配前面的子表达式任意次。例如，zo*能匹配“z”，也能匹配“zo”以及“zoo”。*等价于o{0,}</td>
    </tr>
    <tr>
        <td> +</td>
        <td> 匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td>
    </tr>
    <tr>
        <td> ?</td>
        <td> 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</td>
    </tr>
    <tr>
        <td> {n}</td>
        <td> n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td>
    </tr>
    <tr>
        <td> {n,}</td>
        <td> n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td>
    </tr>
    <tr>
        <td> {n,m}</td>
        <td>m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td>
    </tr>
    <tr>
        <td> ?</td>
        <td>
            当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多的匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少的匹配“o”，得到结果
            ['o', 'o', 'o', 'o']
        </td>
    </tr>
    <tr>
        <td> .点</td>
        <td> 匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。</td>
    </tr>
    <tr>
        <td> (pattern)</td>
        <td>
            匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。
        </td>
    </tr>
    <tr>
        <td> (?:pattern)</td>
        <td>
            非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分时很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。
        </td>
    </tr>
    <tr>
        <td> (?=pattern)</td>
        <td>
            非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
        </td>
    </tr>
    <tr>
        <td> (?!pattern)</td>
        <td>
            非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。
        </td>
    </tr>
    <tr>
        <td> (?&lt;=pattern)</td>
        <td> 非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</td>
    </tr>
    <tr>
        <td> (?&lt;!pattern)</td>
        <td> 非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题
            此处用或任意一项都不能超过2位，如“(?&lt;!95|98|NT|20)Windows正确，“(?&lt;!95|980|NT|20)Windows 报错，若是单独使用则无限制，如(?&lt;!2000)Windows
            正确匹配
        </td>
    </tr>
    <tr>
        <td> x|y</td>
        <td> 匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[zf]ood”则匹配“zood”或“food”。</td>
    </tr>
    <tr>
        <td> [xyz]</td>
        <td> 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</td>
    </tr>
    <tr>
        <td> [^xyz]</td>
        <td> 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。</td>
    </tr>
    <tr>
        <td> [a-z]</td>
        <td> 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围;
            如果出字符组的开头,则只能表示连字符本身.
        </td>
    </tr>
    <tr>
        <td> [^a-z]</td>
        <td> 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td>
    </tr>
    <tr>
        <td> \b</td>
        <td>
            匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。
        </td>
    </tr>
    <tr>
        <td> \B</td>
        <td> 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</td>
    </tr>
    <tr>
        <td> \cx</td>
        <td> 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。</td>
    </tr>
    <tr>
        <td> \d</td>
        <td>匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持</td>
    </tr>
    <tr>
        <td> \D</td>
        <td>匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持</td>
    </tr>
    <tr>
        <td> \f</td>
        <td> 匹配一个换页符。等价于\x0c和\cL。</td>
    </tr>
    <tr>
        <td> \n</td>
        <td> 匹配一个换行符。等价于\x0a和\cJ。</td>
    </tr>
    <tr>
        <td> \r</td>
        <td> 匹配一个回车符。等价于\x0d和\cM。</td>
    </tr>
    <tr>
        <td> \s</td>
        <td> 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td>
    </tr>
    <tr>
        <td> \S</td>
        <td> 匹配任何可见字符。等价于[^ \f\n\r\t\v]。</td>
    </tr>
    <tr>
        <td> \t</td>
        <td> 匹配一个制表符。等价于\x09和\cI。</td>
    </tr>
    <tr>
        <td> \v</td>
        <td> 匹配一个垂直制表符。等价于\x0b和\cK。</td>
    </tr>
    <tr>
        <td> \w</td>
        <td> 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的&quot;单词&quot;字符使用Unicode字符集。</td>
    </tr>
    <tr>
        <td> \W</td>
        <td> 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</td>
    </tr>
    </tbody>
</table>
</body>
</html>